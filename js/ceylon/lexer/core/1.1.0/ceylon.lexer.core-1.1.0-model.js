(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-deps":["ceylon.language\/1.1.0","ceylon.collection\/1.1.0"],"$mod-name":"ceylon.lexer.core","$mod-version":"1.1.0","$mod-bin":"7.0","ceylon.lexer.core":{openCharacterLiteral:{super:{pk:".",nm:"OpenType"},pa:1,mt:"o",an:{doc:["An unterminated [[characterLiteral]]."]},nm:"openCharacterLiteral"},ErrorType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"UnknownType"},{pk:".",nm:"OpenType"}],pa:257,mt:"c",an:{doc:["An erroneous token."]},$at:{string$45jqxo:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"ErrorType"},stringStart:{super:{pk:".",nm:"StringLiteralType"},pa:1,mt:"o",an:{doc:["A string literal that occurs at the beginning of a string template,\ni. e. ends with two backticks instead of a quote, for example:\n\n    \"Hello, ``"]},nm:"stringStart"},stringLiteral:{super:{pk:".",nm:"StringLiteralType"},pa:1,mt:"o",an:{doc:["A regular string literal, for example:\n\n    \"Hello, World!\"\n    \"The Ceylon mascot is Trompon the \\{ELEPHANT}.\""]},nm:"stringLiteral"},ellipsis:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An ellipsis: \u2018`...`\u2019"]},nm:"ellipsis"},spreadMemberOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A spread member operator: \u2018`*.`\u2019"]},nm:"spreadMemberOp"},multiplyAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A multiply-assign operator: \u2018`*=`\u2019"]},nm:"multiplyAssignOp"},binaryLiteral:{super:{pk:".",nm:"IntegerLiteralType"},pa:1,mt:"o",an:{doc:["A binary integer literal, for example:\n\n    $101010"]},nm:"binaryLiteral"},complementOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A complement operator: \u2018`~`\u2019"]},nm:"complementOp"},assemblyKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`assembly`\u2019 keyword."]},nm:"assemblyKw"},verbatimStringLiteral:{super:{pk:".",nm:"StringLiteralType"},pa:1,mt:"o",an:{doc:["A verbatim string literal without escape sequences, for example:\n\n    \"\"\"He said, \"Hello, World!\"\"\"\""]},nm:"verbatimStringLiteral"},LazySequence:{super:{md:"$",pk:"$",nm:"Basic"},mt:"c",sts:[{md:"$",tp:[{mt:"tp",nm:"Element"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"}],tp:[{sts:[{md:"$",pk:"$",nm:"Object"}],nm:"Element"}],$m:{iterator:{$t:{md:"$",tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Iterator"},pa:3,mt:"m",$o:{it$yh8p52:{super:{md:"$",pk:"$",nm:"Basic"},mt:"o",sts:[{md:"$",tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{index$308g1f:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"index"}},nm:"it"}},nm:"iterator"}},$at:{buffer$rxvnnm:{$t:{md:"ceylon.collection",tp:[{mt:"tp",nm:"Element"}],pk:"ceylon.collection",nm:"MutableList"},mt:"a",nm:"buffer"},elements$ffbx99:{$t:{md:"$",tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Iterator"},mt:"a",nm:"elements"}},ps:[{$t:{md:"$",tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Iterator"},mt:"prm",nm:"elements"}],nm:"LazySequence"},unknownCharacter:{super:{pk:".",nm:"UnknownType"},pa:1,mt:"o",an:{doc:["A character that cannot begin any token."]},nm:"unknownCharacter"},largeAsOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An as-large-as operator: \u2018`>=`\u2019"]},nm:"largeAsOp"},continueKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`continue`\u2019 keyword."]},nm:"continueKw"},stringMid:{super:{pk:".",nm:"StringLiteralType"},pa:1,mt:"o",an:{doc:["A string literal that occurs in the middle of a string template,\ni. e. begins and ends with two backticks instead of a quote, for example:\n\n    ``, and welcome to ``"]},nm:"stringMid"},abstractsKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`abstracts`\u2019 keyword."]},nm:"abstractsKw"},backtick:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A backtick: \u2018`` ` ``\u2019"]},nm:"backtick"},floatLiteral:{super:{pk:".",nm:"NumericLiteralType"},pa:1,mt:"o",an:{doc:["A floating point literal, for example:\n\n    1.5\n    10u\n    6.022E23"]},nm:"floatLiteral"},superKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`super`\u2019 keyword."]},nm:"superKw"},lparen:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A left parenthesis: \u2018`(`\u2019"]},nm:"lparen"},TokenSourceStream:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[TokenStream]] that gets its tokens\nfrom an underlying [[TokenSource]].\n\nThis stream supports [[seek]]ing arbitrary indices;\n[[releasing|Marker.destroy]] a marker is a no-op."]},sts:[{pk:".",nm:"TokenStream"}],$m:{peek:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"},seek:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"seek"},consume:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"count"}]],nm:"consume"}},$c:{Marker:{super:{pk:".",nm:"TokenStream.Marker"},pa:3,mt:"c",$m:{destroy:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"prm",nm:"error"}]],nm:"destroy"}},$at:{index:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"a",nm:"index"}},nm:"Marker"}},$at:{source$iesey0:{$t:{pk:".",nm:"TokenSource"},mt:"a",nm:"source"},index$y9uak7:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"index"},tokens$gitv29:{$t:{tp:[{mt:"tp",pk:".",nm:"Token"}],pk:".",nm:"LazySequence"},mt:"a",nm:"tokens"}},ps:[{$t:{pk:".",nm:"TokenSource"},mt:"prm",nm:"source"}],nm:"TokenSourceStream"},whitespace:{super:{pk:".",nm:"IgnoredType"},pa:1,mt:"o",an:{doc:["Whitespace."]},nm:"whitespace"},IgnoredType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"whitespace"},{pk:".",nm:"lineComment"},{pk:".",nm:"multiComment"}],pa:257,mt:"c",an:{doc:["An ignored token that\u2019s not visible to the parser."]},$at:{string$2f0pje:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"IgnoredType"},voidKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`void`\u2019 keyword."]},nm:"voidKw"},LiteralType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"characterLiteral"},{pk:".",nm:"StringLiteralType"},{pk:".",nm:"NumericLiteralType"}],pa:257,mt:"c",an:{doc:["A literal value token."]},$at:{string$8l5gzp:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"LiteralType"},switchKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`switch`\u2019 keyword."]},nm:"switchKw"},openStringPart:{super:{pk:".",nm:"OpenType"},pa:1,mt:"o",an:{doc:["An unterminated [[stringMid]] or [[stringEnd]]."]},nm:"openStringPart"},functionKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`function`\u2019 keyword."]},nm:"functionKw"},decimalLiteral:{super:{pk:".",nm:"IntegerLiteralType"},pa:1,mt:"o",an:{doc:["A decimal integer literal, with an optional magnitude, for example:\n\n    10_000\n    10k"]},nm:"decimalLiteral"},divideAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A divide-assign operator: \u2018`\/=`\u2019"]},nm:"divideAssignOp"},NumericLiteralType:{super:{pk:".",nm:"LiteralType"},of:[{pk:".",nm:"floatLiteral"},{pk:".",nm:"IntegerLiteralType"}],pa:257,mt:"c",an:{doc:["A numeric literal."]},$at:{string$vt2pa2:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"NumericLiteralType"},aliasKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`alias`\u2019 keyword."]},nm:"aliasKw"},specify:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An eager specification operator: \u2018`=`\u2019"]},nm:"specify"},interfaceKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`interface`\u2019 keyword."]},nm:"interfaceKw"},tryKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`try`\u2019 keyword."]},nm:"tryKw"},multiComment:{super:{pk:".",nm:"IgnoredType"},pa:1,mt:"o",an:{doc:["A multi-line comment, for example:\n\n    \/*\n     * comment\n     *\/\n    \n    \/* doesn\u2019t actually have to be multi-line *\/\n    \n    \/* can \/* be *\/ nested *\/"]},nm:"multiComment"},FilteringTokenSource:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[TokenSource]] that filters the tokens from another [[source]]\naccording to a given [[selecting]] function."]},sts:[{pk:".",nm:"TokenSource"}],$m:{selecting$mezqmn:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"m",an:{doc:["The selection function;\nreturn [[true]] if the given [[token]] should yielded,\n[[false]] if it should be filtered."]},ps:[[{$t:{pk:".",nm:"Token"},mt:"prm",an:{doc:["The next token from the underlying [[source]]."]},nm:"token"}]],nm:"selecting"},nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:3,mt:"m",nm:"nextToken"}},$at:{source$8akjhe:{$t:{pk:".",nm:"TokenSource"},mt:"a",an:{doc:["The underlying [[TokenSource]]."]},nm:"source"}},ps:[{$t:{pk:".",nm:"TokenSource"},mt:"prm",an:{doc:["The underlying [[TokenSource]]."]},$hdn:1,nm:"source"},{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"prm",an:{doc:["The selection function;\nreturn [[true]] if the given [[token]] should yielded,\n[[false]] if it should be filtered."]},$hdn:1,$pt:"f",ps:[[{$t:{pk:".",nm:"Token"},mt:"prm",an:{doc:["The next token from the underlying [[source]]."]},nm:"token"}]],nm:"selecting"}],nm:"FilteringTokenSource"},openStringLiteral:{super:{pk:".",nm:"OpenType"},pa:1,mt:"o",an:{doc:["An unterminated [[stringLiteral]] or [[stringStart]]."]},nm:"openStringLiteral"},memberOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A member operator: \u2018`.`\u2019"]},nm:"memberOp"},OpenType:{super:{pk:".",nm:"ErrorType"},of:[{pk:".",nm:"openStringLiteral"},{pk:".",nm:"openStringPart"},{pk:".",nm:"openVerbatimStringLiteral"},{pk:".",nm:"openCharacterLiteral"},{pk:".",nm:"openMultiComment"}],pa:257,mt:"c",an:{doc:["A token that was not terminated. The token stream ends after this token."]},$at:{string$frg2su:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"OpenType"},whileKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`while`\u2019 keyword."]},nm:"whileKw"},andAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An and-assign operator: \u2018`&&=`\u2019"]},nm:"andAssignOp"},newKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`new`\u2019 keyword."]},nm:"newKw"},hexLiteral:{super:{pk:".",nm:"IntegerLiteralType"},pa:1,mt:"o",an:{doc:["A hexadecimal integer literal, for example:\n\n    #10_FFFF"]},nm:"hexLiteral"},openMultiComment:{super:{pk:".",nm:"OpenType"},pa:1,mt:"o",an:{doc:["An unterminated [[multiComment]]."]},nm:"openMultiComment"},IterableTokenSource:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[TokenSource]] that draws its tokens\nfrom a regular [[stream|tokens]]."]},sts:[{pk:".",nm:"TokenSource"}],$m:{nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:3,mt:"m",nm:"nextToken"}},$at:{tokens$czkjcz:{$t:{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"},mt:"a",nm:"tokens"},it$w2gal6:{$t:{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"}],pk:"$",nm:"Iterator"},mt:"a",nm:"it"}},ps:[{$t:{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"},mt:"prm",nm:"tokens"}],nm:"IterableTokenSource"},letKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`let`\u2019 keyword."]},nm:"letKw"},questionMark:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A question mark: \u2018`?`\u2019"]},nm:"questionMark"},openVerbatimStringLiteral:{super:{pk:".",nm:"OpenType"},pa:1,mt:"o",an:{doc:["An unterminated [[verbatimStringLiteral]]."]},nm:"openVerbatimStringLiteral"},remainderOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A remainder operator: \u2018`%`\u2019"]},nm:"remainderOp"},nonemptyKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`nonempty`\u2019 keyword."]},nm:"nonemptyKw"},orAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An or-assign operator: \u2018`||=`\u2019"]},nm:"orAssignOp"},remainderAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A remainder-assign operator: \u2018`%=`\u2019"]},nm:"remainderAssignOp"},elseKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`else`\u2019 keyword."]},nm:"elseKw"},differenceOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A difference operator: \u2018`-`\u2019"]},nm:"differenceOp"},existsKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`exists`\u2019 keyword."]},nm:"existsKw"},lidentifier:{super:{pk:".",nm:"IdentifierType"},pa:1,mt:"o",an:{doc:["An initial lowercase identifier (with optional prefix), for example:\n\n    null\n    \\iSOUTH"]},nm:"lidentifier"},TokenSourceIterable:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["An [[Iterable]] wrapper around a [[TokenSource]].\n\nSince a [[TokenSource]] offers no way to reset itself,\nonly one [[iterator]] may be obtained.\nThis class is thus intended for one-time use only,\nlike this:\n\n    for (token in TokenSourceIterable(CeylonLexer(characters)) {\n        process.write(token.text);\n    }\n\nIt can also be used to obtain a [[sequence]] of all tokens\nthat a [[source]] yields."]},sts:[{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"}],$m:{iterator:{$t:{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"}],pk:"$",nm:"Iterator"},pa:3,mt:"m",an:{throws:["AssertionError","When called more than once."],doc:["Returns the [[source]] on the first call,\nthen throws an [[AssertionError]] on subsequent calls."]},nm:"iterator"}},$at:{src$a4uldx:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"TokenSource"}]},pa:1027,mt:"a",nm:"src"},source$4js57e:{$t:{pk:".",nm:"TokenSource"},mt:"a",nm:"source"}},ps:[{$t:{pk:".",nm:"TokenSource"},mt:"prm",nm:"source"}],nm:"TokenSourceIterable"},smallerOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A smaller-as operator: \u2018`<`\u2019"]},nm:"smallerOp"},thisKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`this`\u2019 keyword."]},nm:"thisKw"},NonIgnoredTokenSource:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[TokenSource]] that filters all [[ignored|IgnoredType]] tokens\nfrom an underlying [[source]].\n\nThis is equivalent to a\n\n    FilteringTokenSource(source, (token) => !t.type is IgnoredType)\n\nbut implemented directly because of performance concerns."]},sts:[{pk:".",nm:"TokenSource"}],$m:{nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:3,mt:"m",nm:"nextToken"}},$at:{source$jb869h:{$t:{pk:".",nm:"TokenSource"},mt:"a",an:{doc:["The underlying [[TokenSource]]."]},nm:"source"}},ps:[{$t:{pk:".",nm:"TokenSource"},mt:"prm",an:{doc:["The underlying [[TokenSource]]."]},$hdn:1,nm:"source"}],nm:"NonIgnoredTokenSource"},importKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`import`\u2019 keyword."]},nm:"importKw"},rbracket:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A right bracket: \u2018`]`\u2019"]},nm:"rbracket"},scaleOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A scale operator: \u2018`**`\u2019"]},nm:"scaleOp"},breakKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`break`\u2019 keyword."]},nm:"breakKw"},characterLiteral:{super:{pk:".",nm:"LiteralType"},pa:1,mt:"o",an:{doc:["A character literal, for example:\n\n    'c'\n    '\\{LATIN SMALL LETTER C}'"]},nm:"characterLiteral"},returnKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`return`\u2019 keyword."]},nm:"returnKw"},givenKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`given`\u2019 keyword."]},nm:"givenKw"},unknownEscape:{super:{pk:".",nm:"UnknownType"},pa:1,mt:"o",an:{doc:["A character other than lower-or uppercase I after a backslash."]},nm:"unknownEscape"},moduleKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`module`\u2019 keyword."]},nm:"moduleKw"},SymbolType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"comma"},{pk:".",nm:"semicolon"},{pk:".",nm:"ellipsis"},{pk:".",nm:"lbrace"},{pk:".",nm:"rbrace"},{pk:".",nm:"lparen"},{pk:".",nm:"rparen"},{pk:".",nm:"lbracket"},{pk:".",nm:"rbracket"},{pk:".",nm:"backtick"},{pk:".",nm:"questionMark"},{pk:".",nm:"memberOp"},{pk:".",nm:"safeMemberOp"},{pk:".",nm:"spreadMemberOp"},{pk:".",nm:"specify"},{pk:".",nm:"compute"},{pk:".",nm:"sumOp"},{pk:".",nm:"differenceOp"},{pk:".",nm:"productOp"},{pk:".",nm:"quotientOp"},{pk:".",nm:"remainderOp"},{pk:".",nm:"powerOp"},{pk:".",nm:"scaleOp"},{pk:".",nm:"incrementOp"},{pk:".",nm:"decrementOp"},{pk:".",nm:"spanOp"},{pk:".",nm:"measureOp"},{pk:".",nm:"entryOp"},{pk:".",nm:"notOp"},{pk:".",nm:"andOp"},{pk:".",nm:"orOp"},{pk:".",nm:"complementOp"},{pk:".",nm:"intersectionOp"},{pk:".",nm:"unionOp"},{pk:".",nm:"identicalOp"},{pk:".",nm:"equalOp"},{pk:".",nm:"notEqualOp"},{pk:".",nm:"smallerOp"},{pk:".",nm:"largerOp"},{pk:".",nm:"smallAsOp"},{pk:".",nm:"largeAsOp"},{pk:".",nm:"compareOp"},{pk:".",nm:"addAssignOp"},{pk:".",nm:"subtractAssignOp"},{pk:".",nm:"multiplyAssignOp"},{pk:".",nm:"divideAssignOp"},{pk:".",nm:"remainderAssignOp"},{pk:".",nm:"andAssignOp"},{pk:".",nm:"orAssignOp"},{pk:".",nm:"complementAssignOp"},{pk:".",nm:"intersectAssignOp"},{pk:".",nm:"unionAssignOp"}],pa:257,mt:"c",an:{doc:["A symbol, that is, an operator or punctuation."]},$at:{string$g17ucs:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"SymbolType"},assertKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`assert`\u2019 keyword."]},nm:"assertKw"},outKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`out`\u2019 keyword."]},nm:"outKw"},dynamicKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`dynamic`\u2019 keyword."]},nm:"dynamicKw"},CharacterSourceStream:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[CharacterStream]] that gets its characters\nfrom an underlying [[CharacterSource]]."]},sts:[{pk:".",nm:"CharacterStream"}],$m:{peek:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"},fill$8s55u8:{$t:{md:"$",pk:"$",nm:"Anything"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"count"}]],nm:"fill"},consume:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"count"}]],nm:"consume"}},$at:{source$8cuio8:{$t:{pk:".",nm:"CharacterSource"},mt:"a",nm:"source"},characters$au111d:{$t:{md:"ceylon.collection",tp:[{md:"$",mt:"tp",pk:"$",nm:"Character"}],pk:"ceylon.collection",nm:"LinkedList"},mt:"a",nm:"characters"}},ps:[{$t:{pk:".",nm:"CharacterSource"},mt:"prm",nm:"source"}],nm:"CharacterSourceStream"},TokenStream:{pa:1,mt:"i",an:{doc:["A stream of tokens\nwith arbitrary lookahead and rewind.\n\nA position within the stream may be marked\nby creating a new [[Marker]]\nand later resumed by [[seek]]ing the marker\u2019s [[index|Marker.index]].\nIt is strongly recommended that this be done\nwithin a try-with-resources structure:\n\n    try (marker = tokens.Marker()) {\n        \/\/ ...\n        if (!success) {\n            tokens.seek(marker.index);\n            \/\/ ...\n        }\n    }\n\nThe nature of the index is unspecified \u2013 despite its name,\nit doesn\u2019t necessarily bear any relation to the current position in the stream,\nand isn\u2019t necessarily strictly monotonically increasing \u2013\nand only a seek to a marked index that hasn\u2019t yet been [[released|Marker.destroy]]\nis guaranteed to succeed.\n\nHowever, other usage of the token stream is not guaranteed to fail,\nand implementations may find it easier to support seeking\nreleased markers, or even arbitrary indices."]},sts:[{pk:".",nm:"TokenSource"}],$m:{nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:11,mt:"m",nm:"nextToken"},peek:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:5,mt:"m",an:{doc:["Peek [[n]] tokens ahead, where `n` must be at least 0.\n\nIf there are not enough tokens in the stream,\n[[null]] is returned instead."]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"},seek:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Reset the position of the stream to the position at which it was\nwhen the [[Marker]] with this [[index]] was created.\n\nThis is only guaranteed to succeed if the [[index]]\ncomes from a [[Marker]] ([[Marker.index]])\nthat hasn\u2019t yet been [[released|Marker.destroy]].\n\nHowever, other usage is unspecified (does not necessarily throw),\nand implementations may also support seeking released or other indices."]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"seek"},consume:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Consume [[count]] tokens."]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"count"}]],nm:"consume"}},$c:{Marker:{super:{md:"$",pk:"$",nm:"Basic"},pa:5,mt:"c",an:{doc:["A marker within the stream.\n\nThe marked position may be restored using [[seek]]\nwhile the marker hasn\u2019t yet been [[released|destroy]].\n\nTo guarantee that the marker will be released when no longer needed,\nusage of the try-with-resources construct is recommended."]},sts:[{md:"$",pk:"$",nm:"Destroyable"}],$m:{destroy:{$t:{md:"$",pk:"$",nm:"Anything"},pa:7,mt:"m",an:{doc:["Releases this marker.\n\nAfter a marker has been released,\n[[seek]]ing its [[index]] may (or may not) fail.\n\nIf multiple markers are created, they should be released\nin reverse order of their creation.\nThis is done automatically if the markers are managed\nusing try-with-resources."]},ps:[[{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{md:"$",pk:"$",nm:"Throwable"}]},mt:"prm",nm:"error"}]],nm:"destroy"}},$at:{index:{$t:{md:"$",pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The index of this marker.\n\nDespite its name, it\u2019s not *necessarily* a proper index,\nand doesn\u2019t have to bear any relation to the current position\nwithin the stream.\nThat is to say, given the markers\n\n    value m1 = tokens.Marker();\n    tokens.consume(n);\n    value m2 = tokens.Marker();\n\nthe intuitive relation\n\n    assert (m2.index == m1.index + n);\n\nisn\u2019t guaranteed to hold.\nIf the nature of the token stream is unknown,\nthis index should rather be seen as an \u201Cid\u201D of the marker.\n\nHowever, implementations may find it convenient to simply return\nan index into an internal list, hence the name."]},nm:"index"}},nm:"Marker"}},nm:"TokenStream"},notOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A not operator: \u2018`!`\u2019"]},nm:"notOp"},catchKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`catch`\u2019 keyword."]},nm:"catchKw"},extendsKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`extends`\u2019 keyword."]},nm:"extendsKw"},CeylonLexer:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A Lexer for the Ceylon programming language,\nturning a stream of [[characters]] into a stream of tokens.\n\n### A note on character and string literals\n\nThis lexer deviates *slightly* from the behavior\nof the official Ceylon compiler in that escape sequences\nfor character and string literals may not contain quotes.\nFor example, the Ceylon compiler will parse these as single literals:\n\n    '\\{FICTITIOUS CHARACTER WITH ' IN NAME}'\n    \"String containing \\{FICTITIOUS CHARACTER WITH \" IN NAME}\"\n\nbecause its grammar has separate rules for these escape sequences\nand doesn\u2019t exit them until encountering the closing brace;\nthis lexer simply terminates the literal\non the first matching unescaped quote.\n\nThis is okay because the [Ceylon 1.1 language specification][Ceylon1.1],\n2.4.2 \u201CCharacter literals\u201D,\ndefines these escape sequences like this:\n\n> ~~~antlr\n> EscapeSequence: \"\\\" (SingleCharacterEscape | \"{\" CharacterCode \"}\")\n> ~~~\n> ~~~antlr\n> CharacterCode: \"#\" ( HexDigit{4} | HexDigit{8} ) | UnicodeCharacterName\n> ~~~\n> \n> Legal Unicode character names are defined by the Unicode specification.\n\nAnd per the [Unicode 7.0.0 specification][Unicode7],\n4.8 \u201CName\u201D, a Unicode character name\nmay contain only a certain set of characters,\nwhich does not include quotes.\n\nTherefore, any program that is lexed differently because of this deviation\ncannot be a legal one.\n\n### A note on numeric literals\n\nThis lexer is slightly more permissive than the grammar from the\n[Ceylon 1.1 language specification][Ceylon1.1] concerning numeric literals;\nit does not enforce\n\n- nonemptiness of exponents (i. e., `1.5E` and `1.5E+` are lexed as legal\n  float literals), and\n- correct grouping of underscores (i. e., `1_000_00.0000_0` is lexed as\n  a legal float literal).\n\nIf desired, they need to be checked at a later stage of compilation.\n\n[Ceylon1.1]: http:\/\/ceylon-lang.org\/documentation\/1.1\/spec\/\n[Unicode7]: http:\/\/www.unicode.org\/versions\/Unicode7.0.0\/"]},sts:[{pk:".",nm:"TokenSource"}],$m:{isIdentifierPart$e9nunj:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"character"}]],nm:"isIdentifierPart"},isIdentifierStart$fb28c0:{$t:{md:"$",pk:"$",nm:"Boolean"},mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"character"}]],nm:"isIdentifierStart"},token$j6uw6i:{$t:{pk:".",nm:"Token"},mt:"m",ps:[[{$t:{pk:".",nm:"TokenType"},mt:"prm",nm:"type"},{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"text"}]],nm:"token"},charToken$743s9o:{$t:{pk:".",nm:"Token"},mt:"m",an:{doc:["Given a single character,\nconsumes that character,\nthen returns a token with that single character."]},ps:[[{$t:{pk:".",nm:"TokenType"},mt:"prm",nm:"type"},{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"text"}]],nm:"charToken"},nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:3,mt:"m",an:{doc:["Returns the next token, or [[null]] if the [[character stream|characters]]\nis depleted.\n\n(There is no `EOF` token.)"]},nm:"nextToken"},identifier$bxp7kq:{$t:{pk:".",nm:"Token"},mt:"m",an:{doc:["Given an initial character of an identifier,\nconsumes that character, then reads on\nuntil the identifier is finished."]},ps:[[{$t:{md:"$",pk:"$",nm:"Character"},mt:"prm",nm:"first"}]],nm:"identifier"}},$at:{terminator$a5hs9k:{$t:{md:"$",pk:"$",nm:"Character"},mt:"a",nm:"terminator"},characters$lzv03:{$t:{pk:".",nm:"CharacterStream"},mt:"a",nm:"characters"}},ps:[{$t:{pk:".",nm:"CharacterStream"},mt:"prm",nm:"characters"}],nm:"CeylonLexer"},unionAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A union-assign operator: \u2018`|=`\u2019"]},nm:"unionAssignOp"},inKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`in`\u2019 keyword."]},nm:"inKw"},lineComment:{super:{pk:".",nm:"IgnoredType"},pa:1,mt:"o",an:{doc:["A single-line comment, for example:\n\n    \/\/ comment\n    #!\/usr\/bin\/ceylon"]},nm:"lineComment"},measureOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A measure operator: \u2018`:`\u2019"]},nm:"measureOp"},classKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`class`\u2019 keyword."]},nm:"classKw"},ofKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`of`\u2019 keyword."]},nm:"ofKw"},IdentifierType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"lidentifier"},{pk:".",nm:"uidentifier"}],pa:257,mt:"c",an:{doc:["An identifier (with optional prefix), for example:\n\n    Anything\n    \\iSOUTH"]},$at:{string$1atccb:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"IdentifierType"},"$pkg-shared":1,intersectAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An intersect-assign operator: \u2018`&=`\u2019"]},nm:"intersectAssignOp"},smallAsOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An as-small-as operator: \u2018`<=`\u2019"]},nm:"smallAsOp"},rparen:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A right parenthesis: \u2018`)`\u2019"]},nm:"rparen"},intersectionOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An intersection operator: \u2018`&`\u2019"]},nm:"intersectionOp"},outerKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`outer`\u2019 keyword."]},nm:"outerKw"},IterableCharacterSource:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[CharacterSource]] that draws its characters\nfrom a regular [[stream|characters]]."]},sts:[{pk:".",nm:"CharacterSource"}],$m:{nextCharacter:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",nm:"nextCharacter"}},$at:{it$lz0xee:{$t:{md:"$",tp:[{md:"$",mt:"tp",pk:"$",nm:"Character"}],pk:"$",nm:"Iterator"},mt:"a",nm:"it"},characters$jz2l19:{$t:{md:"$",tp:[{md:"$",mt:"tp",pk:"$",nm:"Character"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"},mt:"a",nm:"characters"}},ps:[{$t:{md:"$",tp:[{md:"$",mt:"tp",pk:"$",nm:"Character"},{md:"$",mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"},mt:"prm",nm:"characters"}],nm:"IterableCharacterSource"},CharacterStream:{pa:1,mt:"i",an:{doc:["A stream of characters with arbitrary lookahead.\n\nTypical usage can look like this:\n\n    if (cs.peek(0) == 't',\n        cs.peek(1) == 'r',\n        cs.peek(2) == 'y',\n        !isIdentifierPart(cs.peek(3))) {\n        \n        cs.consume(\"try\".size);\n        \/\/ ...\n    }\n\nThe class [[CharacterSourceStream]] may be used\nto turn a [[CharacterSource]] (no lookahead)\ninto a [[CharacterStream]] (arbitrary lookahead)."]},sts:[{pk:".",nm:"CharacterSource"}],$m:{nextCharacter:{$t:{md:"$",pk:"$",nm:"Character"},pa:11,mt:"m",nm:"nextCharacter"},peek:{$t:{md:"$",pk:"$",nm:"Character"},pa:5,mt:"m",an:{doc:["Peek [[n]] characters ahead, where `n` must be at least 0.\n\nIf there are not enough characters in the stream,\nthe character `PRIVATE USE 1` (U+0091) is returned instead."]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"},consume:{$t:{md:"$",pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Consume [[count]] characters."]},ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"count"}]],nm:"consume"}},nm:"CharacterStream"},stringEnd:{super:{pk:".",nm:"StringLiteralType"},pa:1,mt:"o",an:{doc:["A string literal that occurs at the end of a string template,\ni. e. begins with two backticks instead of a quote, for example:\n\n    ``!\""]},nm:"stringEnd"},uidentifier:{super:{pk:".",nm:"IdentifierType"},pa:1,mt:"o",an:{doc:["An initial uppercase identifier (with optional prefix), for example:\n\n    Object\n    \\Iklass"]},nm:"uidentifier"},comma:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A comma: \u2018`,`\u2019"]},nm:"comma"},productOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A product or spread operator: \u2018`*`\u2019"]},nm:"productOp"},complementAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A complement-assign operator: \u2018`~=`\u2019"]},nm:"complementAssignOp"},andOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An and operator: \u2018`&&`\u2019"]},nm:"andOp"},forKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`for`\u2019 keyword."]},nm:"forKw"},equalOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An equality test operator: \u2018`==`\u2019"]},nm:"equalOp"},addAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An add-assign operator: \u2018`+=`\u2019"]},nm:"addAssignOp"},StringLiteralType:{super:{pk:".",nm:"LiteralType"},of:[{pk:".",nm:"stringLiteral"},{pk:".",nm:"verbatimStringLiteral"},{pk:".",nm:"stringStart"},{pk:".",nm:"stringMid"},{pk:".",nm:"stringEnd"}],pa:257,mt:"c",$at:{string$mhtsbm:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"StringLiteralType"},IntegerLiteralType:{super:{pk:".",nm:"NumericLiteralType"},of:[{pk:".",nm:"decimalLiteral"},{pk:".",nm:"hexLiteral"},{pk:".",nm:"binaryLiteral"}],pa:257,mt:"c",an:{doc:["An integer literal."]},$at:{string$pe7xjn:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"IntegerLiteralType"},orOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An or operator: \u2018`||`\u2019"]},nm:"orOp"},largerOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A larger-as operator: \u2018`>`\u2019"]},nm:"largerOp"},quotientOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A quotient operator: \u2018`\/`\u2019"]},nm:"quotientOp"},subtractAssignOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A subtract-assign operator: \u2018`-=`\u2019"]},nm:"subtractAssignOp"},throwKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`throw`\u2019 keyword."]},nm:"throwKw"},safeMemberOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A safe member operator: \u2018`?.`\u2019"]},nm:"safeMemberOp"},KeywordType:{super:{pk:".",nm:"TokenType"},of:[{pk:".",nm:"assemblyKw"},{pk:".",nm:"moduleKw"},{pk:".",nm:"packageKw"},{pk:".",nm:"importKw"},{pk:".",nm:"aliasKw"},{pk:".",nm:"classKw"},{pk:".",nm:"interfaceKw"},{pk:".",nm:"objectKw"},{pk:".",nm:"givenKw"},{pk:".",nm:"valueKw"},{pk:".",nm:"assignKw"},{pk:".",nm:"voidKw"},{pk:".",nm:"functionKw"},{pk:".",nm:"newKw"},{pk:".",nm:"ofKw"},{pk:".",nm:"extendsKw"},{pk:".",nm:"satisfiesKw"},{pk:".",nm:"abstractsKw"},{pk:".",nm:"inKw"},{pk:".",nm:"outKw"},{pk:".",nm:"returnKw"},{pk:".",nm:"breakKw"},{pk:".",nm:"continueKw"},{pk:".",nm:"throwKw"},{pk:".",nm:"assertKw"},{pk:".",nm:"dynamicKw"},{pk:".",nm:"ifKw"},{pk:".",nm:"elseKw"},{pk:".",nm:"switchKw"},{pk:".",nm:"caseKw"},{pk:".",nm:"forKw"},{pk:".",nm:"whileKw"},{pk:".",nm:"tryKw"},{pk:".",nm:"catchKw"},{pk:".",nm:"finallyKw"},{pk:".",nm:"thenKw"},{pk:".",nm:"letKw"},{pk:".",nm:"thisKw"},{pk:".",nm:"outerKw"},{pk:".",nm:"superKw"},{pk:".",nm:"isKw"},{pk:".",nm:"existsKw"},{pk:".",nm:"nonemptyKw"}],pa:257,mt:"c",an:{doc:["A keyword."]},$at:{string$ddhj97:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"KeywordType"},TokenSource:{pa:1,mt:"i",an:{doc:["A stream of tokens."]},sts:[{md:"$",tp:[{mt:"tp",pk:".",nm:"Token"}],pk:"$",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{pk:".",nm:"Token"},{md:"$",pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"},nextToken:{$t:{comp:"u",l:[{md:"$",pk:"$",nm:"Null"},{pk:".",nm:"Token"}]},pa:5,mt:"m",an:{doc:["Returns the next token, or [[null]]\nif there are no more tokens.\n\n(There is no `EOF` token.)"]},nm:"nextToken"}},nm:"TokenSource"},isKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`is`\u2019 keyword."]},nm:"isKw"},lbrace:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A left brace: \u2018`{`\u2019"]},nm:"lbrace"},satisfiesKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`satisfies`\u2019 keyword."]},nm:"satisfiesKw"},identicalOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An identity test operator: \u2018`===`\u2019"]},nm:"identicalOp"},UnknownType:{super:{pk:".",nm:"ErrorType"},of:[{pk:".",nm:"unknownCharacter"},{pk:".",nm:"unknownEscape"}],pa:257,mt:"c",an:{doc:["A token where the lexer does not understand a character,\nbut is able to proceed past it."]},$at:{string$yy668i:{$t:{md:"$",pk:"$",nm:"String"},mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},mt:"prm",nm:"string"}],nm:"UnknownType"},TokenType:{super:{md:"$",pk:"$",nm:"Basic"},of:[{pk:".",nm:"IgnoredType"},{pk:".",nm:"IdentifierType"},{pk:".",nm:"LiteralType"},{pk:".",nm:"KeywordType"},{pk:".",nm:"SymbolType"},{pk:".",nm:"ErrorType"}],pa:257,mt:"c",$at:{string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"prm",$hdn:1,nm:"string"}],nm:"TokenType"},rbrace:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A right brace: \u2018`}`\u2019"]},nm:"rbrace"},powerOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A power operator: \u2018`^`\u2019"]},nm:"powerOp"},valueKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`value`\u2019 keyword."]},nm:"valueKw"},sumOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A sum operator: \u2018`+`\u2019"]},nm:"sumOp"},CharacterSource:{pa:1,mt:"i",an:{doc:["A stream of characters, without any navigation abilities."]},$m:{nextCharacter:{$t:{md:"$",pk:"$",nm:"Character"},pa:5,mt:"m",an:{doc:["The next character in the stream, or the character\n`PRIVATE USE 1` (U+0091)\nif there are no more characters in the stream.\n\nReturning a special character instead of [[null]]\nallows us to have the return type `Character`,\nwhich has several advantages over `Character?`:\n- it can be compared directly with the `==` operator\n- on the Java backend, a `switch` on it is compiled\n  to a Java `switch` (on `int`) instead of a slower\n  `if` \/ `else if` chain (with equality checks\n  on [[ceylon.language::Character]] objects)."]},nm:"nextCharacter"}},nm:"CharacterSource"},compute:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A lazy specification operator: \u2018`=>`\u2019"]},nm:"compute"},thenKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`then`\u2019 keyword."]},nm:"thenKw"},entryOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An entry operator: \u2018`->`\u2019"]},nm:"entryOp"},packageKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`package`\u2019 keyword."]},nm:"packageKw"},spanOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A span operator: \u2018`..`\u2019"]},nm:"spanOp"},lbracket:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A left bracket: \u2018`[`\u2019"]},nm:"lbracket"},unionOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A union operator: \u2018`|`\u2019"]},nm:"unionOp"},assignKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`assign`\u2019 keyword."]},nm:"assignKw"},Token:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A single token, that is,\na fragment of code with a certain [[type]].\n\nFor most token types, the [[type]] determines the [[text]];\nonly the following token types can have varying text:\n- identifiers:\n    - [[lidentifier]]\n    - [[uidentifier]]\n- literals:\n    - [[decimalLiteral]]\n    - [[hexLiteral]]\n    - [[binaryLiteral]]\n    - [[floatLiteral]]\n    - [[stringLiteral]]\n    - [[verbatimStringLiteral]]\n    - [[stringStart]]\n    - [[stringMid]]\n    - [[stringEnd]]\n- ignored:\n    - [[whitespace]]\n    - [[lineComment]]\n    - [[multiComment]]"]},$m:{equals:{$t:{md:"$",pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"}},$at:{text:{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"a",nm:"text"},hash:{$t:{md:"$",pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},type:{$t:{pk:".",nm:"TokenType"},pa:1,mt:"a",nm:"type"}},ps:[{$t:{pk:".",nm:"TokenType"},pa:1,mt:"prm",$hdn:1,nm:"type"},{$t:{md:"$",pk:"$",nm:"String"},pa:1,mt:"prm",$hdn:1,nm:"text"}],nm:"Token"},StringCharacterStream:{super:{md:"$",pk:"$",nm:"Basic"},pa:1,mt:"c",an:{doc:["A [[CharacterStream]] that reads its characters from a [[string]]."]},sts:[{pk:".",nm:"CharacterStream"}],$m:{peek:{$t:{md:"$",pk:"$",nm:"Character"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"n"}]],nm:"peek"},consume:{$t:{md:"$",pk:"$",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{md:"$",pk:"$",nm:"Integer"},def:1,mt:"prm",nm:"count"}]],nm:"consume"}},$at:{characters$5md7yr:{$t:{md:"$",tp:[{md:"$",mt:"tp",pk:"$",nm:"Character"}],pk:"$",nm:"Sequential"},mt:"a",nm:"characters"},string:{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"a",nm:"string"},index$6grf7f:{$t:{md:"$",pk:"$",nm:"Integer"},pa:1024,mt:"a",nm:"index"}},ps:[{$t:{md:"$",pk:"$",nm:"String"},pa:3,mt:"prm",nm:"string"}],nm:"StringCharacterStream"},caseKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`case`\u2019 keyword."]},nm:"caseKw"},decrementOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A decrement operator: \u2018`--`\u2019"]},nm:"decrementOp"},incrementOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["An increment operator: \u2018`++`\u2019"]},nm:"incrementOp"},compareOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A compare operator: \u2018`<=>`\u2019"]},nm:"compareOp"},semicolon:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A semicolon: \u2018`;`\u2019"]},nm:"semicolon"},notEqualOp:{super:{pk:".",nm:"SymbolType"},pa:1,mt:"o",an:{doc:["A non-equality test-operator: \u2018`!=`\u2019"]},nm:"notEqualOp"},ifKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`if`\u2019 keyword."]},nm:"ifKw"},finallyKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`finally`\u2019 keyword."]},nm:"finallyKw"},objectKw:{super:{pk:".",nm:"KeywordType"},pa:1,mt:"o",an:{doc:["The \u2018`object`\u2019 keyword."]},nm:"objectKw"}}};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
